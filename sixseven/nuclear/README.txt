-----------------------------------------------------------------------------------------------
nuc_burn.py is the main script with only functions defined. the burn() function is the only function you need from here. 
you should import nuc_burn at the top of your script.
- nuc_burn.burn() takes inputs of temp: float, rho: float, time: float, comps=None
# 'temps', 'rhos', and 'comps' should be arrays (number of elements = number of shells (dms)). 'time' is your time step in seconds. 
# burn() outputs a list of NetOut structs that contain the results for each shell evolved over the time step.
# This includes energy, Composition object, etc.

************ If you want to access epsilon/mean molecular weight/Composition object for all of the shells , here is a code to do so: *************

epsilon = []
mu = []
composition = [] # Composition object per shell

for i,j in enumerate(results):
    epsilon.append(j.energy)
    mu.append(j.composition.getMeanParticleMass()) 
    composition.append(j.composition) 

Important note:
# for the very first time step, leave 'comps' as none (it calls a function with an initial composition) (default of comps is None, so you can leave it blank)
# for the following time steps, update 'comps' with the previous burn() output mass fractions per shell 
 

 # The Composition object for each shell contains functions that access the molar abundance, mean molecular weight, etc. 

*************************************** Example usage ***************************************** 
- For initial run
temps = np.linspace(1.5e7, 2e7, 100)
rhos = np.linspace(1.5e2, 1.5e2, 100)
results = nuc_burn.burn(temps, rhos, 1000)

- For following run:
results2 = nuc_burn.burn(newtemps, newrhos, 1000, newcomps)
- and so on...

********** To see the functions/properties you can access within results: **********
print(results[0].__dir__())
The output and their definitions:
 'composition' - final composition after evolving to tMax
 'num_steps' - number of steps the solver took to evolve to tmax
 'energy' - final specific energy generated by the network while evolving to tMax
 'dEps_dT' - derivative of energy with respect to temperature at the end of the evolution
 'dEps_dRho' - derivative of energy with respect to density at the end of the evolution
 'specific_neutrino_flux' - total flux of neutrinos while evolving to tMax
 'specific_neutrino_energy_loss' - total specific energy lost to neutrinos while evolving to tMax

# To access molar abundance from Composition object:
print(results[0].composition.getMolarAbundance("H-1")) # this is the Composition object for the first shell of the star, to access them, you must iterate through each shell 

# To see what functions an object like Composition has:
print(results.composition.__dir__())

# To access epsilon for the first shell: 
print(results[0].energy) # 0 is the first index, so if you wanted all epsilons, follow the code given prior to the example usage code above. 

To run burn() within a time stepping function without a bunch of stuff outputting to your terminal,
use burn() within a script and call the script with:
python myscript.py > stdout 2>&1 
- you can then type 'cat stdout' to see the logging of your code if you want to check for errors or anything.
-----------------------------------------------------------------------------------------------
scratch.py has the same code as nuc_burn.py, but is where I played with stuff and left messy comments for myself. 
this code can be run + altered if needed for trouble-shooting. it has arrays with dummy values defined for temp and rho at the end of the script, and a print statement.
-----------------------------------------------------------------------------------------------
test.py is simply testing the importing of nuc_burn and the functionality of burn() with dummy values for temps and rhos.